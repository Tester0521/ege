from math import ceil


#######################################################################################################################
########################################		19		###############################################################
########################################  2/3 действия  ###############################################################

########		НЕУДАЧНЫЙ ХОД ПЕТИ		########

def _19_1(mx, p, n1, n2=0) -> int: return int(ceil(mx/p**2))

########		ЛЮБОЙ ХОД ПЕТИ		########		

def _19_2(mx, p, n1, n2=0) -> int: return int(ceil(mx/p-n1))

#######################################################################################################################
########################################		20		###############################################################
########################################	2 действия  ###############################################################
# Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
# — Петя не может выиграть за один ход;
# — Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.

def _20_1(mx, p, n1) -> str: return f'{int((ceil(mx / p)-n1)/p)}{ceil(mx/p)-n1*2}'

########################################	3 действия  ###############################################################
def _20_2(mx, p, n1, n2=0) -> str: return f"{ceil(mx/p)-n1-n2}{ceil(mx/p)-n1-n1}"  #if mx%2!=0  \
			#else f"{int((ceil(mx/p)-n1)/p)} {ceil(mx/p)-n1-n2} (вот еще -> {ceil(mx/p)-n1-n1})"

#---------------------------------------	3 значения ---------------------------------------------------------------#

def _20_3(mx, p, n1, n2=0) -> str: return f"{int((ceil(mx/p)-n1)/p)}{ceil(mx/p)-n1-n2} {ceil(mx/p)-n1-n1}"

#######################################################################################################################
########################################		21		###############################################################
########################################	2 действия  ###############################################################
# Найдите минимальное значение S, при котором одновременно выполняются два условия:
# — у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# — у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

def _21_1(mx, p, n1) -> int: return int((ceil(mx/p)-n1)/p-n1) if ((ceil(mx/p)-n1*2)/p)*p**3 < mx \
										else int((ceil(mx/p)-n1)-n1*2)

########################################	3 действия  ###############################################################

def _21_2(mx, p, n1, n2=0) -> int: return int((ceil(mx/p)-n1)/p-n1) if ((ceil(mx/p)-n1-n2)/p)*p**3 < mx \
										else int((ceil(mx/p)-n1)-n2-n1)

print('TESTS -->')
print('2 ДЕЙСТВИЯ >>')
print('№28145')
print(_19_1(94, 2, 1), end = '  ||  ')
print(_20_1(94, 2, 1), end = '  ||  ')
print(_21_1(94, 2, 1))
print('№28155')
print(_19_1(22, 2, 1), end = '  ||  ')
print(_20_1(22, 2, 1), end = '  ||  ')
print(_21_1(22, 2, 1))
print('3 ДЕЙСТВИЯ >>')
print('№27832')
print(_19_1(52, 2, 1, 4), end = '  ||  ')
print(_20_2(52, 2, 1, 4), end = '  ||  ')
print(_21_2(52, 2, 1, 4))
print('№27848')
print(_19_1(54, 2, 1, 3), end = '  ||  ')
print(_20_3(54, 2, 1, 3), end = '  ||  ')
print(_21_2(54, 2, 1, 3))































########################################		ROOTS		###########################################################
#######################################################################################################################
########################################		FOOTER		###########################################################
#######################################################################################################################
'''print(ceil(mx * n3**2), "|||", f'{ceil(mx*n3)-n1-n2}{ceil(mx*n3)-n1-n1}'  if mx%2!=0  \
			else f'{int((ceil(mx*n3)-n1)*n3)}{ceil(mx*n3)-n1-n2} (вот еще -> {ceil(mx*n3)-n1-n1})', \
			"|||", ceil(mx*n3)-n1-n2-n1  if mx%2!=0  \
			else (int((ceil(mx*n3)-n1)*n3-n1)))'''

# V1.0 28059-61
'''print(ceil(27 * 0.5**2), f'{ceil(27*0.5)-1-2}{ceil(27*0.5)-1-1}'  if 27%2!=0  \
			else f'{(ceil(27*0.5)-1)*0.5}{ceil(27*0.5)-1-2}', \
			ceil(27*0.5)-1-2-1  if 27%2!=0  \
			else (ceil(27*0.5)-1)*0.5-1 )'''





#######################################################################################################################
########################################		USEFUL		###########################################################
#######################################################################################################################
########################################		massive	(LOSE)	##########################################################
def mass(p, mx, n_1=1, n_2=2, n_3=3, inc_2=2, inc_3=3, inc_4=4,):
	# mas = [[j for j in range(p**2)] for i in range(p**2)]
	mas = [[1]*p**2 for i in range(p**2)]
	for n in range(1, mx-1):
		mas[0] = [n]*p**2
		for x in mas:
			pass


	return mas

def rocks19(plus:  int = 1, inc: int = 2, win: int = 129):
	for el in range(1, win - 1):
		if el * inc >= win:
			return el-plus

def rocks20(plus:  int = 1, inc: int = 2, win: int = 129):
	for el in range(1, win - 1):
		if el * inc > win // inc and el + plus > win // inc:
			return f'{min([el - plus, el // inc])}{max([el - plus, el // inc])}'

def rocks21(plus:  int = 1, inc: int = 2, win: int = 129):
	for el in range(1, win - 1):
		if el*inc > win // 2: 
			if (el+plus) * inc == win // 2:
				return el
			elif el + (plus*3) > win // 2:
				return el
# print(rocks19())
# print(rocks20())
# print(rocks21())

def f1(n): return n + 1
def f2(n): return n * 2
def f3(n): return n + 2
##############################################################################################################
'''def press_f(vic: int, arr: list) -> list:
	res1, res2, res3 = 0, 0, 0
	for s in range(1, vic - 1):
		for f in arr:
			def _19_():
				for f2 in arr:
		    		if f2(f(s)) > vic // 2:
		    			res1 = s - 1
		    			break
		    def _20_():
		    	for f2 in arr:
		    		if f2(f(s)) '''
		    
# print(press_f(27, [f1, f2, f3], 2, 3))
##############################################################################################################

'''def gg(vic: int, **fs) -> list:
	res1 = ceil(27 * 0.5**2)
	res2 = f'{ceil(27*0.5)-1-2}{ceil(27*0.5)-1-1}'  if 27%2!=0  \
			else f'{(ceil(27*0.5)-1)*0.5}{ceil(27*0.5)-1-2}'
	res3 = ceil(27*0.5)-1-2-1  if 27%2!=0  \
			else (ceil(27*0.5)-1)*0.5-1
	return [res1, res2, res3]'''
##############################################################################################################


